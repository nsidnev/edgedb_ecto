defmodule EdgeDBEcto do
  @autogenerated_fields ~w(
    id
    inserted_at
    updated_at
  )a
  @fields_to_drop Enum.reduce(@autogenerated_fields, [], &[&1, Atom.to_string(&1) | &2])

  defmacro __using__(opts \\ []) do
    {opts, _bindings} = Code.eval_quoted(opts, [], __CALLER__)
    edgedb_name = Keyword.fetch!(opts, :name)
    define_queries? = Keyword.get(opts, :queries, false)

    quote do
      if unquote(define_queries?) do
        use EdgeDBEcto.Queries, unquote(opts)
      end

      def transaction(conn \\ nil, %Ecto.Multi{} = multi) do
        conn = conn || unquote(edgedb_name)
        unquote(__MODULE__).transaction(conn, multi)
      end
    end
  end

  def transaction(conn, %Ecto.Multi{} = multi) do
    operations = Ecto.Multi.to_list(multi)

    EdgeDB.transaction(conn, fn conn ->
      operations
      |> Enum.reduce_while(%{__conn__: conn}, &handle_multi_step/2)
      |> Map.drop([:__conn__])
    end)
  end

  def insert(schema_or_changeset, callback, opts \\ [])

  def insert(%Ecto.Changeset{} = changeset, callback, opts) do
    case opts[:nested] do
      true ->
        apply_changes(changeset, callback)

      _other ->
        changeset
        |> apply_prepare()
        |> Ecto.Changeset.apply_action!(:edgedb)
        |> insert(callback, opts)
    end
  end

  # schema's insert is limited only to a single schema + links ids
  # link id is passed as {association_name}_id/ids param
  def insert(schema, callback, opts) do
    params_to_keep = Keyword.get(opts, :keep, [])

    params =
      schema
      |> schema_to_params()
      |> Map.drop(@fields_to_drop -- params_to_keep)

    case callback.(params) do
      {:error, _reason} = error ->
        error

      {:ok, _result} = result ->
        result

      result ->
        {:ok, result}
    end
  end

  def update(%Ecto.Changeset{} = changeset, callback) do
    apply_changes(changeset, callback)
  end

  # to execute through Ecto.Multi
  def update_all(callback, _params, _opts) do
    callback.()
  end

  def delete_all(callback, _opts) do
    callback.()
  end

  defp handle_multi_step(
         {name, {:insert, %Ecto.Changeset{} = changeset, opts}},
         %{__conn__: conn} = acc
       ) do
    callback = fn params ->
      opts[:callback].(params, edgedb: [conn: conn])
    end

    case insert(changeset, callback, opts) do
      {:ok, schema} ->
        {:cont, Map.put(acc, name, schema)}

      {:error, _reason} = error ->
        {:halt, error}
    end
  end

  defp handle_multi_step(
         {name, {_action, %Ecto.Changeset{} = changeset, opts}},
         %{__conn__: conn} = acc
       ) do
    callback = fn params ->
      opts[:callback].(params, edgedb: [conn: conn])
    end

    case apply_changes(changeset, callback) do
      {:ok, schema} ->
        {:cont, Map.put(acc, name, schema)}

      {:error, _reason} = error ->
        {:halt, error}
    end
  end

  defp handle_multi_step({name, {:run, operation}}, acc) do
    case operation.(__MODULE__, acc) do
      {:error, _reason} = error ->
        {:halt, error}

      {:ok, result} ->
        {:cont, Map.put(acc, name, result)}

      result ->
        {:cont, Map.put(acc, name, result)}
    end
  end

  # params will be passed to query as JSON
  defp apply_changes(%Ecto.Changeset{} = changeset, callback) do
    with {:ok, params} <- changeset_to_params(changeset) do
      case callback.(params: params) do
        {:error, _reason} = error ->
          error

        {:ok, _result} = result ->
          result

        result ->
          {:ok, result}
      end
    end
  end

  defp changeset_to_params(changeset) do
    changeset = apply_prepare(changeset)

    with {:ok, schema} <- Ecto.Changeset.apply_action(changeset, :edgedb) do
      id = Ecto.Changeset.get_change(changeset, :id, schema.id)
      params = extract_changes(changeset)
      {:ok, Map.put_new(params, :id, id)}
    end
  end

  defp extract_changes(changeset) do
    Enum.into(changeset.changes, %{}, fn
      {key, [%Ecto.Changeset{} | _rest] = values} ->
        {key, Enum.map(values, &extract_changes(&1))}

      {key, value} ->
        {key, value}
    end)
  end

  # params from schema will be passed as named params
  defp schema_to_params(%{__struct__: schema_mod} = schema) do
    fields = schema_mod.__schema__(:fields)
    associations = schema_mod.__schema__(:associations)

    relation_fields =
      Enum.map(associations, fn association_name ->
        association = schema_mod.__schema__(:association, association_name)
        association.owner_key
      end)

    properties = fields -- relation_fields

    schema
    |> Map.from_struct()
    |> Map.drop([:__meta__])
    |> Enum.reduce(%{}, fn
      {_key, %Ecto.Association.NotLoaded{}}, acc ->
        acc

      {key, [%_struct{__meta__: _meta} | _rest] = associations}, acc ->
        ids =
          associations
          |> Enum.map(& &1.id)
          |> Enum.reject(&is_nil/1)

        case ids do
          [] ->
            acc

          _other ->
            Map.put(acc, "#{key}_ids", ids)
        end

      {_key, %_struct{__meta__: _meta, id: nil}}, acc ->
        acc

      {key, %_struct{__meta__: _meta, id: id}}, acc ->
        Map.put(acc, "#{key}_id", id)

      {key, value}, acc ->
        if key in properties do
          Map.put(acc, key, value)
        else
          acc
        end
    end)
  end

  defp apply_prepare(changeset) do
    Enum.reduce(changeset.prepare, changeset, fn callback, changeset ->
      callback.(changeset)
    end)
  end
end
